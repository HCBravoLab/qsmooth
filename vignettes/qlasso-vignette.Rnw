%\VignetteIndexEntry{The qlasso user's guide}
%\VignettePackage{qlasso}
%\VignetteEngine{knitr::knitr}
\documentclass{article}

<<style-knitr, eval=TRUE, echo=FALSE, results="asis">>=
    BiocStyle::latex()
@

\setlength{\parskip}{1\baselineskip}
\setlength{\parindent}{0pt}

\title{The \texttt{qlasso} user's guide}
\author{Kwame Okrah \texttt{kwame.okrah@gmail.com} \and
Hector Corrado Bravo \texttt{hcorrada@gmail.com} \and
Stephanie C. Hicks \texttt{shicks@jimmy.harvard.edu} \and
Rafael A. Irizarry \texttt{rafa@jimmy.harvard.edu} }

\date{Modified: March 5, 2015.  Compiled: \today}


\begin{document}

\maketitle
 
\tableofcontents

\section{Introduction}

Add introduction here. 

\section{Getting Started}

Load the \texttt{qlasso} package in R. 

<<lib-load, message=FALSE>>=
library(quantro)
library(HTShape)
library(qlasso)
@


\section{Data}

\subsection{Pickrell Data Example}
Load an example data set. Here we use the Pickrell data set. 
(but we can change this to whatever). 

<<load-data>>=
data(examplesData)
names(examplesData)
counts = examplesData$pickrell$exprs
groups = examplesData$pickrell$cond
@

\section{Exploratory Data Analysis}

In this section we will look at summary plots
of the raw data.

% 
% <<librarysize, fig.width=4.5, fig.height=2.5, fig.align='center', echo=FALSE>>=
%  par(mgp=c(1.5, 0.5, 0), mar=c(2.5, 2.5, 1, 0.5))
%  
%  groupCol = ifelse(groups=="female", "steelblue", "tomato")
%  
%  barplot(colSums(counts), col=groupCol, main="Library size",
%          xaxt="none", xlab="Samples", ylab="Reads aligned")
% @

First, we will filter out genes with low counts with the \texttt{filterCounts}
function. This function will only retain genes whose counts per million (cpm)
exceeds 1 (can be changed, see the \texttt{thresh} parameter) in a given
number of samples (see the \texttt{minSamples} parameter).

<<filterOut-lowCountGenes>>=
(minSamples <- min(table(groups)))
dim(counts)
counts = filterCounts(counts, thresh=1, minSamples=minSamples)
dim(counts)
@

Density plots
<<density, fig.width=5, fig.height=3, fig.align='center', echo=FALSE>>=
par(mgp=c(1.5, 0.5, 0), mar=c(2.5, 2.5, 1, 0.5))

groupCol = ifelse(groups=="female", "steelblue", "tomato")

# (note) will not work for data.frame ?
matdensity(as.matrix(log2(counts + 1)), xlab="log2(counts+1)", 
           groupFactor=factor(groups, levels=unique(groups)), 
           col=unique(groupCol), main="Raw counts (log2(counts + 1))",
           ylab="Density")
legend("topright", legend=unique(groups), fill=unique(groupCol))
@

\subsection{Samples shape assessment}

In this section we will formally test whether the transcriptome
shapes (densities) differ due to a factor of interest. In this case
sex. We will use both quantro and HTShape for this test and compare results.

\subsubsection{L-ratios manova stat.}

First we will use the \texttt{shapeManova} function in HTShape 
(see HTShape for more details). This method first summarizes each
sample in the data set with scale-free skewness and kurtosis coefficients
(L-skew and L-kurt). These shape esitmates are based on the theory of L-moments 
(cite:Hosking1990, Okrah2015). We perform a multivariate analysis of 
variance based on the shape (L-skew, L-kurt) esitmates
(see xxx for more details).

<<lrats, fig.width=5, fig.height=3, fig.align='center', echo=FALSE>>=
# compute l-ratios
par(mgp=c(1.5, 0.5, 0), mar=c(4.5, 2.5, 1, 0.5))

(pval <- shapeManova(log2(counts+1), groups))
@

The pvalue of 0.151 indicates that sex and transcriptome shape are not
related.

\subsubsection{Quantro stat.}

Use qauntro for the same test. 

<<qtest>>=
(qtest <- quantro(log2(counts+1), groups, verbose=FALSE, B=500))
@

Conclusions are the same as shapeManova. 

\section{Using \texttt{qlasso} for normalization}

\subsection{Scale samples}
Scale samples using trimmed mean. Trim off top and bottom 0.25 quantiles.
Other methods can be used (eg. AH, median, mean).

Density plots
<<scale-counts, fig.width=5, fig.height=3, fig.align='center', echo=FALSE>>=
par(mgp=c(1.5, 0.5, 0), mar=c(2.5, 2.5, 1, 0.5))

scaled.counts = scaleData(counts + 1, type="trim.mean")

# (note) will not work for data.frame ?
matdensity(as.matrix(log2(scaled.counts)), xlab="log2(counts+1)", 
           groupFactor=factor(groups, levels=unique(groups)), 
           col=unique(groupCol), main="log2(trim.mean scaled.counts)",
           ylab="Density")
legend("topright", legend=unique(groups), fill=unique(groupCol))
@


\subsection{Computing quantiles}

The sample quantiles of the raw data, reference quantile, 
and shrinkage weights can be computed using the 
\texttt{qstats()} function. The reference quantile 
can be computed as a average across sample quantiles 
(as in full quantile normalization) or can be obtained
by taking the median across reference quantiles. 
The \texttt{refType} parameter specifies which type
of reference quantile to use.

<<compute-quantiles>>=
qs = qstats(exprs=log2(scaled.counts), groups=groups,
            refType="mean", groupLoc="mean", window=99)
@

plots weights
<<weights, fig.width=5, fig.height=3, fig.align='center', echo=FALSE>>=
par(mgp=c(1.5, 0.5, 0), mar=c(2.5, 2.5, 1, 0.5))

u = (1:nrow(scaled.counts) - 0.5) / nrow(scaled.counts)

sel = sort(sample(1:nrow(scaled.counts), 1000)) 

plot(u[sel], qs$roughWeights[sel], pch=".", col="gray60",
     ylab="Weights", xlab="u (normalized gene ranks)",
     main="Reference weights")
abline(v=0.5, lty=2)
points(u[sel], qs$smoothWeights[sel], pch=".", col="red")
@


\subsection{\texttt{qshrink} normalized values}

The normalized values are computed using the 
\texttt{qshrink} function. 
This function is based on the resultys of \texttt{qstats}.
We do not need to call \texttt{qstats}. It was shown 
above for demonstration.

<<qshrikage>>=
normExprs = qshrink(exprs=log2(scaled.counts), groups=groups,
                    refType="mean", groupLoc="mean", window=99)
@

Boxplots
<<boxplots-normExprs, fig.width=5, fig.height=3, fig.align='center', echo=FALSE>>=
par(mgp=c(1.5, 0.5, 0), mar=c(2.5, 2.5, 1, 0.5))

matboxplot(normExprs, groupFactor=factor(groups, levels=unique(groups)), 
           col=unique(groupCol), main="Quantile Shrinkage Normalized",
           xaxt="none", xlab="Samples", range=0)
@

Density plots
<<density-normExprs, fig.width=5, fig.height=3, fig.align='center', echo=FALSE>>=
par(mgp=c(1.5, 0.5, 0), mar=c(2.5, 2.5, 1, 0.5))

# (note) will not work for data.frame ?
matdensity(as.matrix(normExprs), xlab="log2(counts+1)", 
           groupFactor=factor(groups, levels=unique(groups)), 
           col=unique(groupCol), main="Quantile Shrinkage Normalized",
           ylab="Density")
legend("topright", legend=unique(groups), fill=unique(groupCol))
@


\section{SessionInfo}

<<sessionInfo,results ='markup'>>=
sessionInfo()
@


\end{document}